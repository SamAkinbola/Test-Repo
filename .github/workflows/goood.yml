name: RUBIX_DEV_TEST

on:
  push:
    tags:
      - "v*" # Trigger on version tags (e.g., v1.0.0)
    paths:
      - "Database/" # Only trigger if changes are in Database/ path

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout repository
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch full history for branch comparison

      # Step 2: Verify tag commit exists on dev branch
      - name: Verify tag commit is on dev branch
        run: |
          TAG_COMMIT=$(git rev-parse "${{ github.sha }}")
          echo "Tag commit: $TAG_COMMIT"

          # Fetch dev branch
          git fetch origin dev:dev

          if git merge-base --is-ancestor "$TAG_COMMIT" origin/dev; then
            echo "✅ Tag commit is on dev branch. Continuing..."
          else
            echo "❌ Tag commit is NOT on dev branch. Exiting."
            exit 0
          fi

      # Step 3: Identify changed SQL files in Database/ since the last tag or dev commit
      - name: Identify Changed SQL Files
        id: changed_files
        run: |
          echo "Identifying changed SQL files"
          SQL_DIR="Database"

          if [ ! -d "$SQL_DIR" ]; then
            echo "SQL directory $SQL_DIR does not exist. Skipping deployment."
            exit 0
          fi

          # Get the previous tag (if any) or use dev branch HEAD^ for comparison
          PREV_COMMIT=$(git describe --tags --abbrev=0 --match="v*" HEAD^ 2>/dev/null || git rev-parse origin/dev^)
          CURR_COMMIT=$(git rev-parse "${{ github.sha }}")

          echo "Comparing commits $PREV_COMMIT..$CURR_COMMIT"

          # Check for new or modified .sql files in Database/
          CHANGED_FILES=$(git diff --name-only "$PREV_COMMIT" "$CURR_COMMIT" -- "$SQL_DIR" | grep -i '\.sql$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No new or modified SQL files found in $SQL_DIR. Skipping deployment."
            exit 0
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Pass changed files to output
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 4: Install SnowSQL client
      - name: Install SnowSQL
        env:
          SNOWSQL_PRIVATE_KEY_PASSPHRASE: "${{ secrets.SF_DW_PROD_TEST_PRIVATE_KEY_PWD }}"
        run: |
          curl -O https://sfc-repo.snowflakecomputing.com/snowsql/bootstrap/1.3/linux_x86_64/snowsql-1.3.2-linux_x86_64.bash
          SNOWSQL_DEST=/bin SNOWSQL_LOGIN_SHELL=/.profile bash snowsql-1.3.2-linux_x86_64.bash

      # Step 5: Prepare private key for Snowflake authentication
      - name: Prepare user private key
        run: |
          printf '%s\n' "${{ secrets.SF_DW_PROD_TEST_USER_PRIVATE_KEY }}" > ./private_key.pem

      # Step 6: Deploy changed SQL files to Snowflake
      - name: Deploy Changed SQL Files to Snowflake
        if: steps.changed_files.outputs.changed_files != ''
        run: |
          echo "Deploying changed SQL files"
          SQL_DIR="Database"
          CHANGED_FILES="${{ steps.changed_files.outputs.changed_files }}"

          DEPLOYED_FILES=""
          FAILED_FILES=""

          echo "$CHANGED_FILES" | while read -r file; do
            if [ -f "$file" ]; then
              echo "Executing $file..."
              if ~/bin/snowsql -a ${{ secrets.SF_DW_PROD_TEST_ACCOUNT }} -u ${{ secrets.SF_DW_PROD_TEST_USER }} --private-key-path ./private_key.pem -f "$file" -d ${{ secrets.SF_DW_PROD_TEST_DB }} -r ${{ secrets.SF_DW_PROD_TEST_ROLE }} -w ${{ secrets.SF_DW_PROD_TEST_WH }} -o log_level=DEBUG; then
                DEPLOYED_FILES="$DEPLOYED_FILES\n$file"
              else
                FAILED_FILES="$FAILED_FILES\n$file"
              fi
            else
              echo "File $file does not exist. Skipping."
            fi
          done

          # Write results to summary
          {
            echo "### Deployment Summary"
            if [ -n "$DEPLOYED_FILES" ]; then
              echo "✅ Successfully deployed:"
              echo "$DEPLOYED_FILES"
            fi
            if [ -n "$FAILED_FILES" ]; then
              echo "❌ Failed deployments:"
              echo "$FAILED_FILES"
            fi
          } >> $GITHUB_STEP_SUMMARY
