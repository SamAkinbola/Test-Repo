name: Snowflake Deployment Pipeline
on:
  workflow_dispatch: # Manual trigger
  push:
    branches:
      - prod
    paths:
      - "Database/" # Trigger on changes to Database/ and its subdirectories
    tags:
      - 'v*..' # Trigger on tags matching vX.Y.Z (e.g., v1.0.0)
      - 'release-*' # Trigger on tags starting with release- (e.g., release-2025-08-24)

jobs:
  deploy:
    runs-on: ubuntu-22.04

    env:
      SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
      SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}
      SNOWFLAKE_PRIVATE_KEY: ${{ secrets.SNOWFLAKE_PRIVATE_KEY }}
      SNOWFLAKE_PRIVATE_KEY_PASSPHRASE: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_PASSPHRASE }}
      SNOWFLAKE_ROLE: ${{ secrets.SNOWFLAKE_ROLE }}
      SNOWFLAKE_WAREHOUSE: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
      SNOWFLAKE_DATABASE: ${{ secrets.SNOWFLAKE_DATABASE }}
      SNOWFLAKE_SCHEMA: ${{ secrets.SNOWFLAKE_SCHEMA }}

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch full history to access tags and compare changes

      - name: Install OpenSSL Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libssl-dev openssl

      - name: Debug OpenSSL Version
        run: |
          openssl version
          ls -l /usr/lib/x86_64-linux-gnu/libcrypto*

      - name: Install SnowSQL
        run: |
          curl -O https://sfc-repo.snowflakecomputing.com/snowsql/bootstrap/1.2/linux_x86_64/snowsql-1.2.30-linux_x86_64.bash
          SNOWSQL_DEST=/bin SNOWSQL_LOGIN_SHELL=/.profile bash snowsql-1.2.30-linux_x86_64.bash

      - name: Debug Environment Variables
        run: |
          echo "SNOWFLAKE_ACCOUNT: $SNOWFLAKE_ACCOUNT"
          echo "SNOWFLAKE_USER: $SNOWFLAKE_USER"
          echo "SNOWFLAKE_ROLE: $SNOWFLAKE_ROLE"
          echo "SNOWFLAKE_WAREHOUSE: $SNOWFLAKE_WAREHOUSE"
          echo "SNOWFLAKE_DATABASE: $SNOWFLAKE_DATABASE"
          echo "SNOWFLAKE_SCHEMA: $SNOWFLAKE_SCHEMA"

      - name: Debug Secret Availability
        run: |
          if [ -z "$SNOWFLAKE_PRIVATE_KEY" ]; then
            echo "SNOWFLAKE_PRIVATE_KEY is empty or unset"
            exit 1
          else
            echo "SNOWFLAKE_PRIVATE_KEY is set (value not shown for security)"
          fi
          if [ -z "$SNOWFLAKE_PRIVATE_KEY_PASSPHRASE" ]; then
            echo "SNOWFLAKE_PRIVATE_KEY_PASSPHRASE is empty or unset"
            exit 1
          else
            echo "SNOWFLAKE_PRIVATE_KEY_PASSPHRASE is set (value not shown for security)"
          fi

      - name: Write Private Key to File
        run: |
          echo "$SNOWFLAKE_PRIVATE_KEY" > private_key.p8
          chmod 600 private_key.p8

      - name: Identify Changed SQL Files
        id: changed_files
        run: |
          echo "Identifying changed SQL files"
          SQL_DIR="Database"
          if [ ! -d "$SQL_DIR" ]; then
            echo "SQL directory $SQL_DIR does not exist. Skipping deployment."
            exit 0
          fi
          # If triggered by a tag, get SQL files changed since the last tag
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_type }}" == "tag" ]]; then
            echo "Tag push detected: ${{ github.ref_name }}"
            LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -z "$LAST_TAG" ]; then
              echo "No previous tag found, using all SQL files in $SQL_DIR"
              CHANGED_FILES=$(find "$SQL_DIR" -type f -name "*.sql" | sort || true)
            else
              echo "Comparing with previous tag: $LAST_TAG"
              CHANGED_FILES=$(git diff --name-only --diff-filter=AM "$LAST_TAG" HEAD "$SQL_DIR/" | grep '\.sql$' | sort || true)
            fi
          else
            # For branch pushes, get changed SQL files since last commit
            CHANGED_FILES=$(git diff --name-only --diff-filter=AM HEAD^ HEAD "$SQL_DIR/" | grep '\.sql$' | sort || true)
          fi
          if [ -z "$CHANGED_FILES" ]; then
            echo "No new or modified SQL files found. Skipping deployment."
            exit 0
          fi
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Deploy Changed SQL Files to Snowflake
        if: steps.changed_files.outputs.changed_files != ''
        run: |
          echo "Deploying changed SQL files"
          SQL_DIR="Database"
          CHANGED_FILES="${{ steps.changed_files.outputs.changed_files }}"
          if [ -z "$CHANGED_FILES" ]; then
            echo "No SQL files to deploy."
            exit 0
          fi
          echo "$CHANGED_FILES" | while read file; do
            if [ -f "$file" ]; then
              echo "Executing $file..."
              OBJECT_TYPE=$(basename "$file" | sed 's/\.sql$//')
              echo "Object type inferred: $OBJECT_TYPE"
              export SNOWSQL_PRIVATE_KEY_PASSPHRASE="$SNOWFLAKE_PRIVATE_KEY_PASSPHRASE"
              ~/bin/snowsql -a "$SNOWFLAKE_ACCOUNT" \
                            -u "$SNOWFLAKE_USER" \
                            -r "$SNOWFLAKE_ROLE" \
                            -w "$SNOWFLAKE_WAREHOUSE" \
                            -d "$SNOWFLAKE_DATABASE" \
                            -s "$SNOWFLAKE_SCHEMA" \
                            --private-key-path private_key.p8 \
                            -f "$file" \
                            -o friendly=false \
                            -o multi_statement=true \
                            -o log_level=DEBUG || {
                echo "Failed executing $file"
                exit 1
              }
            else
              echo "File $file does not exist. Skipping."
            fi
          done
        env:
          changed_files: ${{ steps.changed_files.outputs.changed_files }}

      - name: Clean Up Private Key
        if: always()
        run: |
          if [ -f private_key.p8 ]; then
            rm -f private_key.p8
            echo "Private key file removed"
          fi
